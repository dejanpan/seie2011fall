#include <ros/ros.h>
#include <simple_robot_control/robot_control.h>
#include <math.h>

using namespace std;

int main(int argc, char** argv){



        ros::init(argc, argv, "robot_control_test_app");
        ros::NodeHandle nh;

        //Create robot controller interface
        simple_robot_control::Robot robot;


        //specify grab pose with postion and orientation as StampedTransform
        tf::StampedTransform tf_init (tf::Transform(tf::Quaternion(0,0,0,1),
            tf::Vector3(0.8,0.0,1.1)),
            ros::Time::now(),"base_link","doesnt_matter");
        robot.right_arm.moveGrippertoPose(tf_init);

//+++++++++++++++++++++++++++++++++TEST++++++++++++++++++++++++++++++++++++++++
        for(int i=0;i<=360;i+=20){
                	float r,x,y;

                	// radius of the circle trajectory
                	r=0.1;
                	//x position on circle /0.4 for (180 degree)/ 0.5 for (90 & 270 degree)/ 0.6 for (0 & 360 degree)
                	x= ((cos((M_PI*i)/180))*r)+0.46;
                	//y position on circle -0.05 for 0.25 (90 & 270 degree)/ 0.1 for (0 & 180 & 360 degree)
                	y= ((sin((M_PI*i)/180))*r)-0.15;

                	tf::Transform trans;
                	tf::Quaternion axis;

					float yaw_angle = (M_PI+(M_PI*((float)i/180)));
                	float pitch_angle = 0.24*M_PI;

//                	trans.setOrigin(tf::Vector3(x,y,0.5));
//                	trans.setRotation(tf::Quaternion(0,0,0,1));
//                	result = trans * axis;
//                	z_axis.setOrigin(tf::Vector3(0,0,0));
//                	z_axis.setRotation(btQuaternion(btVector3(0.0,0.0,1.0),yaw_angle));
//                	y_axis.setOrigin(tf::Vector3(0,0,0));
//                	y_axis.setRotation(btQuaternion(btVector3(0.0,1.0,0.0),0.15*M_PI));
//                	result = trans * z_axis * y_axis;

                	axis.setRPY(0.0,pitch_angle,yaw_angle);

                    tf::StampedTransform update (tf::Transform(axis,tf::Vector3(x,y,0.5)),
                    ros::Time::now(),"base_link","doesnt_matter");
                    cout<<"degree = "<<i << endl;
                    cout<<"pitch = "<<pitch_angle <<"  yaw = "<<yaw_angle<< endl;
                    robot.right_arm.moveGrippertoPose(update, 10);

//                    tf::StampedTransform update (result,
//                    ros::Time::now(),"base_link","doesnt_matter");
//                    cout<<"degree = "<<i << endl;
//                    robot.right_arm.moveGrippertoPose(update, 10);
        }
//+++++++++++++++++++++++++++++++++TEST++++++++++++++++++++++++++++++++++++++++



//#########################WORKING SOLUTION START##############################################

//       for(int i=0;i<=360;i+=20){
//        	float r,x,y;
//        	r=0.1;
//        	x= ((cos((M_PI*i)/180))*r)+0.8;
//        	y= ((sin((M_PI*i)/180))*r);
//
//        	tf::Transform first, sec, result;
//
//        	first.setOrigin(tf::Vector3(x,y,0.7));
//        	first.setRotation(tf::Quaternion(0,0,0,1));
//        	sec.setOrigin(tf::Vector3(0,0,0));
//        	sec.setRotation(tf::Quaternion(0,1,0,45));
//
//        	result = first * sec;
//
//            tf::StampedTransform update (result,
//            ros::Time::now(),"base_link","doesnt_matter");
//            robot.right_arm.moveGrippertoPose(update, 10);
//
//
//       }

//#########################WORKING SOLUTION START##############################################

        return 0;

}



