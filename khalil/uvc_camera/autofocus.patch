diff --git a/uvc_camera/CMakeLists.txt b/uvc_camera/CMakeLists.txt
index 948de6f..04012d2 100644
--- a/uvc_camera/CMakeLists.txt
+++ b/uvc_camera/CMakeLists.txt
@@ -34,8 +34,10 @@ gencfg()
 #target_link_libraries(example ${PROJECT_NAME})
 
 #rosbuild_add_executable(uvc_stereo src/uvc_stereo.cpp src/uvc_cam.cpp)
+include_directories(/usr/include/glib-2.0 /usr/lib/x86_64-linux-gnu/glib-2.0/include /usr/lib/glib-2.0/include)
 rosbuild_add_library(nodelet_uvc_camera src/nodelets.cpp src/camera.cpp src/stereo.cpp src/uvc_cam.cpp)
 
-rosbuild_add_executable(camera_node src/camera_node.cpp src/camera.cpp src/uvc_cam.cpp)
-rosbuild_add_executable(stereo_node src/stereo_node.cpp src/stereo.cpp src/uvc_cam.cpp)
+rosbuild_add_executable(camera_node src/camera_node.cpp src/camera.cpp src/autofocus.cpp src/dct.cpp src/ms_time.cpp src/uvc_cam.cpp)
+#rosbuild_add_executable(stereo_node src/stereo_node.cpp src/stereo.cpp src/uvc_cam.cpp)
+target_link_libraries(camera_node glib-2.0)
 
diff --git a/uvc_camera/include/uvc_cam/autofocus.h b/uvc_camera/include/uvc_cam/autofocus.h
new file mode 100644
index 0000000..dbdb979
--- /dev/null
+++ b/uvc_camera/include/uvc_cam/autofocus.h
@@ -0,0 +1,73 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#           Dr. Alexander K. Seewald <alex@seewald.at>                          #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+/*******************************************************************************#
+#                                                                               #
+#  autofocus - using dct for sharpness measure                                  #
+#                                                                               #
+#                                                                               #
+********************************************************************************/
+
+#ifndef AUTOFOCUS_H
+#define AUTOFOCUS_H
+
+#include "defs.h"
+
+#define MAX_ARR_S 20
+struct focusData
+{
+
+	int focus;
+	int step;
+	int old_focus;
+	int right;
+	int left;
+	int sharpness;
+	int focus_sharpness;
+	int sharpLeft;
+	int sharpRight;
+    int id;
+	int f_max;
+	int f_min;
+	int f_step;
+	int i_step;
+	int focusDir;
+	int arr_sharp[MAX_ARR_S];
+	int arr_foc[MAX_ARR_S];
+	int ind;
+	int flag;
+	int setFocus;
+	int focus_wait;
+};
+
+ struct focusData *initFocusData (int f_max, int f_min, int step, int id);
+
+int getSharpness (unsigned char* img, int width, int height, int t);
+
+int getSharpMeasure (BYTE *img, int width, int height, int t);
+
+int getFocusVal (struct focusData *AFdata);
+
+
+#endif
+
+
diff --git a/uvc_camera/include/uvc_cam/dct.h b/uvc_camera/include/uvc_cam/dct.h
new file mode 100644
index 0000000..8778424
--- /dev/null
+++ b/uvc_camera/include/uvc_cam/dct.h
@@ -0,0 +1,41 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+/*******************************************************************************#
+#                                                                               #
+#  dct for Jpeg encoder                                                         #
+#                                                                               # 
+#  Adapted for linux, Paulo Assis, 2007 <pj.assis@gmail.com>                    #
+********************************************************************************/
+
+#ifndef DCT_H
+#define DCT_H
+
+#include "defs.h"
+
+/* Level shifting to get 8 bit SIGNED values for the data  */
+void levelshift (INT16* const data);
+
+/* DCT for One block(8x8) */
+void DCT (INT16 *data);
+
+#endif
+
diff --git a/uvc_camera/include/uvc_cam/defs.h b/uvc_camera/include/uvc_cam/defs.h
new file mode 100755
index 0000000..4ecf129
--- /dev/null
+++ b/uvc_camera/include/uvc_cam/defs.h
@@ -0,0 +1,142 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+#ifndef DEFS_H
+#define DEFS_H
+#include <inttypes.h>
+#include <sys/types.h>
+
+#define CLEAR_LINE "\x1B[K"
+
+#ifdef WORDS_BIGENDIAN
+  #define BIGENDIAN 1
+#else
+  #define BIGENDIAN 0
+#endif
+
+#define IO_MMAP 1
+#define IO_READ 2
+
+#define ODD(x) ((x%2)?TRUE:FALSE)
+
+/*next index of ring buffer with size elements*/
+#define NEXT_IND(ind,size) ind++;if(ind>=size) ind=0
+/*previous index of ring buffer with size elements*/
+//#define PREV_IND(ind,size) ind--;if(ind<0) ind=size-1
+
+#define VIDBUFF_SIZE 45    //number of video frames in the ring buffer
+#define AUDBUFF_SIZE 100   //number of audio mpeg frames in the ring buffer
+#define MPG_NUM_SAMP 1152  //number of samples in a audio MPEG frame 
+//#define MPG_NUM_FRAMES 2   //number of MPEG frames in a audio frame
+
+typedef uint64_t QWORD;
+typedef uint32_t DWORD;
+typedef uint16_t WORD;
+typedef uint8_t  BYTE;
+typedef unsigned int LONG;
+typedef unsigned int UINT;
+
+typedef unsigned long long ULLONG;
+typedef unsigned long      ULONG;
+
+typedef char* pchar;
+
+typedef int8_t     INT8;
+typedef uint8_t    UINT8;
+typedef int16_t    INT16;
+typedef uint16_t   UINT16;
+typedef int32_t    INT32;
+typedef uint32_t   UINT32;
+typedef int64_t    INT64;
+typedef uint64_t   UINT64;
+
+typedef float SAMPLE;
+
+/* 0 is device default*/
+static const int stdSampleRates[] = 
+{ 
+	0, 8000,  9600, 11025, 12000,
+	16000, 22050, 24000,
+	32000, 44100, 48000,
+	88200, 96000,
+	-1   /* Negative terminated list. */
+};
+
+/*----------- guvcview version ----------------*/
+//#define VERSION ("") /*defined in config.h*/
+#define DEBUG (0)
+/*---------- Thread Stack Size (bytes) --------*/
+#define TSTACK (128*64*1024) /* Debian Default 128 pages of 64k = 8388608 bytes*/
+
+/*----------- AVI max file size ---------------*/
+#define AVI_MAX_SIZE (1900*1024*1024)
+/* extra size beyond MAX SIZE at wich we can still write data*/ 
+#define AVI_EXTRA_SIZE (20*1024*1024)
+
+#define INCPANTILT 64 // 1°
+
+#define WINSIZEX 480
+#define WINSIZEY 700
+
+#define AUTO_EXP 8
+#define MAN_EXP	1
+
+#define DHT_SIZE 432
+
+#define DEFAULT_WIDTH 640
+#define DEFAULT_HEIGHT 480
+
+#define DEFAULT_IMAGE_FNAME	"Image.jpg"
+#define DEFAULT_AVI_FNAME	"capture.avi"
+#define DEFAULT_FPS	25
+#define DEFAULT_FPS_NUM 1
+#define SDL_WAIT_TIME 30 /*SDL - Thread loop sleep time */
+
+/*clip value between 0 and 255*/
+#define CLIP(value) (BYTE)(((value)>0xFF)?0xff:(((value)<0)?0:(value)))
+
+/*MAX macro - gets the bigger value*/
+#ifndef MAX
+#define MAX(a,b) (((a) < (b)) ? (b) : (a))
+#endif
+
+/*FILTER FLAGS*/
+#define YUV_NOFILT (0)
+#define YUV_MIRROR (1<<0)
+#define YUV_UPTURN (1<<1)
+#define YUV_NEGATE (1<<2)
+#define YUV_MONOCR (1<<3)
+#define YUV_PIECES (1<<4)
+#define YUV_PARTICLES (1<<5)
+
+/*Audio Effects*/
+#define SND_NOEF   (0)
+#define SND_ECHO   (1<<0)
+#define SND_FUZZ   (1<<1)
+#define SND_REVERB (1<<2)
+#define SND_WAHWAH (1<<3)
+#define SND_DUCKY  (1<<4)
+
+/* On Screen Display flags*/
+#define OSD_METER  (1<<0)
+
+#endif
+
diff --git a/uvc_camera/include/uvc_cam/ms_time.h b/uvc_camera/include/uvc_cam/ms_time.h
new file mode 100644
index 0000000..4e4ce4d
--- /dev/null
+++ b/uvc_camera/include/uvc_cam/ms_time.h
@@ -0,0 +1,47 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+#ifndef MS_TIME_H
+#define MS_TIME_H
+
+#include <glib.h>
+#include "defs.h"
+
+#ifndef G_NSEC_PER_SEC
+#define G_NSEC_PER_SEC 1000000000LL
+#endif
+
+/*time in miliseconds*/
+DWORD ms_time (void);
+/*time in microseconds*/
+ULLONG us_time(void);
+/*time in nanoseconds (real time for benchmark)*/
+ULLONG ns_time (void);
+/*MONOTONIC CLOCK in nano sec for time stamps*/
+UINT64 ns_time_monotonic();
+
+/*sleep for given time in ms*/
+void sleep_ms(int ms_time);
+
+/*wait on cond by sleeping for n_loops of sleep_ms ms */
+/*(test (var == val) every loop)                      */
+int wait_ms(gboolean* var, gboolean val, GMutex *mutex, int ms_time, int n_loops);
+#endif
+
diff --git a/uvc_camera/include/uvc_cam/test.cpp b/uvc_camera/include/uvc_cam/test.cpp
new file mode 100644
index 0000000..eaf4030
--- /dev/null
+++ b/uvc_camera/include/uvc_cam/test.cpp
@@ -0,0 +1,6 @@
+#include "autofocus.h"
+
+int main()
+{
+	printf("hello\n");
+}
\ No newline at end of file
diff --git a/uvc_camera/include/uvc_cam/uvc_cam.h b/uvc_camera/include/uvc_cam/uvc_cam.h
index a10cb72..d84f5cd 100644
--- a/uvc_camera/include/uvc_cam/uvc_cam.h
+++ b/uvc_camera/include/uvc_cam/uvc_cam.h
@@ -25,6 +25,7 @@
 #include <string>
 #include <linux/videodev2.h>
 #include <stdint.h>
+#include "autofocus.h"
 
 namespace uvc_cam
 {
@@ -63,6 +64,8 @@ public:
   bool set_auto_white_balance(bool on);
   void set_motion_thresholds(int lum, int count);
   void set_control(uint32_t id, int val);
+  void auto_focus(struct focusData *AFdata,unsigned char* frame);
+
 private:
   std::string device;
   int fd, motion_threshold_luminance, motion_threshold_count;
diff --git a/uvc_camera/launch/camera_node.launch b/uvc_camera/launch/camera_node.launch
index 95a6390..ee72d4e 100644
--- a/uvc_camera/launch/camera_node.launch
+++ b/uvc_camera/launch/camera_node.launch
@@ -1,10 +1,10 @@
 <launch>
   <node pkg="uvc_camera" type="camera_node" name="uvc_camera" output="screen">
-    <param name="width" type="int" value="320" />
-    <param name="height" type="int" value="240" />
+    <param name="width" type="int" value="640" />
+    <param name="height" type="int" value="480" />
     <param name="fps" type="int" value="30" />
     <param name="frame" type="string" value="wide_stereo" />
-    <param name="device" type="string" value="/dev/video0" />
+    <param name="device" type="string" value="/dev/video1" />
     <param name="camera_info_url" type="string" value="file://$(find uvc_camera)/example.yaml" />
   </node>
 </launch>
diff --git a/uvc_camera/src/autofocus.cpp b/uvc_camera/src/autofocus.cpp
new file mode 100644
index 0000000..cb55a29
--- /dev/null
+++ b/uvc_camera/src/autofocus.cpp
@@ -0,0 +1,513 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#           Dr. Alexander K. Seewald <alex@seewald.at>                          #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+/*******************************************************************************#
+#                                                                               #
+#  autofocus - using dct                                                        #
+#                                                                               #
+#                                                                               #
+********************************************************************************/
+
+#include "uvc_cam/autofocus.h"
+#include "uvc_cam/dct.h"
+#include "uvc_cam/defs.h"
+#include "uvc_cam/ms_time.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib.h>
+#include <math.h>
+
+/*use insert sort - it's the fastest for small and almost sorted arrays (our case)*/
+#define SORT (3) //1 - Quick sort   2 - Shell sort  3- insert sort  other - bubble sort
+
+#define _TH_		(80) // default treshold = 1/80 of focus sharpness value
+
+#define FLAT 		(0)
+#define LOCAL_MAX	(1)
+#define LEFT		(2)
+#define RIGHT		(3)
+#define INCSTEP		(4)
+
+#define SWAP(x, y) temp = (x); (x) = (y); (y) = temp
+
+static double sumAC[64];
+static int ACweight[64] = {
+	0,1,2,3,4,5,6,7,
+	1,1,2,3,4,5,6,7,
+	2,2,2,3,4,5,6,7,
+	3,3,3,3,4,5,6,7,
+	4,4,4,4,4,5,6,7,
+	5,5,5,5,5,5,6,7,
+	7,7,7,7,7,7,7,7
+};
+
+struct focusData *initFocusData (int f_max, int f_min, int step, int id) 
+{
+	struct focusData* AFdata = g_new0(struct focusData, 1);
+	if(AFdata == NULL) 
+		return (AFdata);
+    AFdata->id = id;
+	AFdata->f_max = f_max;
+	AFdata->f_min = f_min;
+	AFdata->f_step = step;
+	AFdata->i_step = (f_max + 1 - f_min)/32;
+	if(AFdata->i_step <= step) AFdata->i_step = step * 2;
+	//g_printf("focus step:%i\n", AFdata->i_step);
+	AFdata->right = f_max;
+	AFdata->left = f_min + AFdata->i_step; /*start with focus at 8*/
+	AFdata->focus = -1;
+	AFdata->focus_wait = 0;
+	memset(sumAC,0,64);
+	/*all other values are 0 */
+	return (AFdata);
+}
+
+#if (SORT == 1)
+/*quick sort (the fastest and more complex - recursive, doesn't do well on almost sorted data)*/
+static void q_sort(struct focusData *AFdata, int left, int right)
+{
+	int pivot, l_hold, r_hold, temp;
+
+	l_hold = left;
+	r_hold = right;
+	pivot = AFdata->arr_sharp[left];
+	temp = AFdata->arr_foc[left];
+	
+	while(left < right)
+	{
+		while((AFdata->arr_sharp[right] >= pivot) && (left < right))
+			right--;
+		if (left != right)
+		{
+			AFdata->arr_sharp[left] = AFdata->arr_sharp[right];
+			AFdata->arr_foc[left] = AFdata->arr_foc[right];
+			left++;
+		}
+		while((AFdata->arr_sharp[left] <= pivot) && (left < right))
+			left++;
+		if (left != right)
+		{
+			AFdata->arr_sharp[right] = AFdata->arr_sharp[left];
+			AFdata->arr_foc[right] = AFdata->arr_foc[left];
+			right--;
+		}
+	}
+	AFdata->arr_sharp[left] = pivot;
+	AFdata->arr_foc[left] = temp;
+	pivot = left;
+	left = l_hold;
+	right = r_hold;
+	if (left < pivot) q_sort(AFdata, left, pivot-1);
+	if (right > pivot) q_sort(AFdata, pivot+1, right);
+}
+#elif (SORT == 2)  
+/* shell sort (based on insert sort, but with some optimization)*/
+/* for small arrays insert sort is still faster */
+void s_sort(struct focusData *AFdata, int size)
+{
+	int i, j, temp, gap;
+	
+	for (gap = size / 2; gap > 0; gap /= 2)
+	{
+		for (i = gap; i <= size; i++)
+		{
+			for (j = i-gap; j >= 0 && (AFdata->arr_sharp[j] > AFdata->arr_sharp[j + gap]); j -= gap) 
+			{
+				SWAP(AFdata->arr_sharp[j], AFdata->arr_sharp[j + gap]);
+				SWAP(AFdata->arr_foc[j], AFdata->arr_foc[j + gap]);
+			}
+		}
+	}
+}
+
+#elif (SORT == 3)
+/*insert sort (fastest for small arrays, around 15 elements)*/
+static void i_sort (struct focusData *AFdata, int size)
+{
+	int i,j,temp;
+	
+	for (i = 1; i <= size; i++) 
+	{
+		for(j = i; j > 0 && (AFdata->arr_sharp[j-1] > AFdata->arr_sharp[j]); j--)
+		{
+			SWAP(AFdata->arr_sharp[j],AFdata->arr_sharp[j-1]);
+			SWAP(AFdata->arr_foc[j],AFdata->arr_foc[j-1]);
+		}
+	}
+}
+
+#else
+/*buble sort (the simplest and most inefficient) - in real test with focus data*/
+/*it did better than shell or quick sort (focus data is almost sorted)*/
+static void b_sort (struct focusData *AFdata, int size) 
+{
+	int i, temp, swapped;
+	
+	do 
+	{
+		swapped = 0;
+		size--;
+		for (i=0;i<=size;i++) 
+		{
+			if (AFdata->arr_sharp[i+1] < AFdata->arr_sharp[i]) 
+			{
+				SWAP(AFdata->arr_sharp[i],AFdata->arr_sharp[i+1]);
+				SWAP(AFdata->arr_foc[i],AFdata->arr_foc[i+1]);
+				swapped = 1;
+			}
+		}
+	} while (swapped);
+}
+#endif
+
+static int Sort(struct focusData *AFdata, int size)
+{
+	if (size>=20) 
+	{
+		g_printerr("WARNING: focus array size=%d exceeds 20\n",size);
+		size = 10;
+	}
+#if (SORT == 1)
+	q_sort(AFdata, 0, size);
+#elif (SORT == 2)
+	s_sort(AFdata, size);
+#elif (SORT == 3)
+	i_sort(AFdata, size);
+#else
+	b_sort(AFdata, size);
+#endif
+	/*better focus value*/
+	return(AFdata->arr_foc[size]);
+}
+
+/* extract lum (y) data from image    (YUYV)                */
+/* img - image data pointer                                 */
+/* dataY - pointer for lum (y) data                         */
+/* width - width of img (in pixels)                         */
+/* height - height of img (in pixels)                       */
+static INT16* extractY (BYTE* img, INT16* dataY, int width, int height) 
+{
+	int i=0;
+	BYTE *pimg;
+	pimg=img;
+	
+	for (i=0;i<(height*width);i++) 
+	{
+		dataY[i]=(INT16) *pimg++;
+		pimg++;
+	}
+	
+	return (dataY);
+}
+
+/* measure sharpness in MCU                 */
+/* data - MCU data [8x8]                    */
+/* t - highest order coef.                  */
+static void getSharpnessMCU (INT16 *data, double weight)
+{
+
+	int i=0;
+	int j=0;
+
+	levelshift (data);
+	DCT (data);
+
+	for (i=0;i<8;i++) 
+	{
+		for(j=0;j<8;j++) 
+		{
+			sumAC[i*8+j]+=data[i*8+j]*data[i*8+j]*weight;
+		}	
+	}	
+}
+
+/* sharpness in focus window */
+int getSharpness (unsigned char* img, int width, int height, int t)
+{
+	float res=0;
+	int numMCUx = width/(8*2); /*covers 1/2 of width - width should be even*/
+	int numMCUy = height/(8*2); /*covers 1/2 of height- height should be even*/
+	INT16 dataMCU[64];
+	INT16* data;
+	INT16 dataY[width*height];
+	INT16 *Y = dataY;
+	
+	double weight;
+	double xp_;
+	double yp_;
+	int ctx = numMCUx >> 1; /*center*/ 
+	int cty = numMCUy >> 1;
+	double rad=ctx/2; 
+	if (cty<ctx) { rad=cty/2; }
+	rad=rad*rad;
+	int cnt2 =0;
+	
+	data=dataMCU;
+
+	Y = extractY (img, Y, width, height);
+	
+	int i=0;
+	int j=0;
+	int xp=0;
+	int yp=0;
+	/*calculate MCU sharpness*/
+	for (yp=0;yp<numMCUy;yp++) 
+	{
+		yp_=yp-cty;
+    		for (xp=0;xp<numMCUx;xp++) 
+		{
+			xp_=xp-ctx;
+			weight = exp(-(xp_*xp_)/rad-(yp_*yp_)/rad);
+			for (i=0;i<8;i++) 
+			{
+				for(j=0;j<8;j++) 
+				{
+					/*center*/
+					dataMCU[i*8+j]=Y[(((height-(numMCUy-(yp*2))*8)>>1)+i)*width
+						+(((width-(numMCUx-(xp*2))*8)>>1)+j)];
+				}
+			}
+			getSharpnessMCU(data,weight);
+			cnt2++;
+		}
+	}
+	
+	for (i=0;i<=t;i++) 
+	{
+		for(j=0;j<t;j++) 
+		{
+			sumAC[i*8+j]/=(double) (cnt2); /*average = mean*/
+			res+=sumAC[i*8+j]*ACweight[i*8+j];
+		}
+	}
+	return (roundf(res*10)); /*round to int (4 digit precision)*/
+}
+
+
+static int checkFocus(struct focusData *AFdata) 
+{
+	/*change treshold according to sharpness*/
+	int TH = _TH_; 
+	//if(AFdata->focus_sharpness < (5 * _TH_)) TH = _TH_ * 4 ;
+	
+	if (AFdata->step <= AFdata->i_step) 
+	{
+		if (abs((AFdata->sharpLeft-AFdata->focus_sharpness)<(AFdata->focus_sharpness/TH)) && 
+			(abs(AFdata->sharpRight-AFdata->focus_sharpness)<(AFdata->focus_sharpness/TH))) 
+		{
+			return (FLAT);
+		}
+		else if (((AFdata->focus_sharpness-AFdata->sharpRight))>=(AFdata->focus_sharpness/TH) && 
+			((AFdata->focus_sharpness-AFdata->sharpLeft))>=(AFdata->focus_sharpness/TH)) 
+		{
+			// significantly down in both directions -> check another step
+			// outside for local maximum
+			//AFdata->step=16;
+			return (INCSTEP);
+		}
+		else 
+		{
+			// one is significant, the other is not...
+			int left=0; int right=0;
+			if (abs((AFdata->sharpLeft-AFdata->focus_sharpness))>=(AFdata->focus_sharpness/TH)) 
+			{
+				if (AFdata->sharpLeft>AFdata->focus_sharpness) left++;  
+				else right++; 
+			}
+			if (abs((AFdata->sharpRight-AFdata->focus_sharpness))>=(AFdata->focus_sharpness/TH)) 
+			{
+				if (AFdata->sharpRight>AFdata->focus_sharpness) right++; 
+				else left++;
+			}
+			if (left==right) return (FLAT);
+			else if (left>right) return (LEFT);
+			else return (RIGHT);
+		}
+	}
+	else 
+	{
+		if (((AFdata->focus_sharpness-AFdata->sharpRight))>=(AFdata->focus_sharpness/TH) && 
+			((AFdata->focus_sharpness-AFdata->sharpLeft))>=(AFdata->focus_sharpness/TH)) 
+		{
+			return (LOCAL_MAX);
+		}
+		else 
+		{
+			return (FLAT);
+		}
+	}
+}
+
+int getFocusVal (struct focusData *AFdata) 
+{
+	int step = AFdata->i_step * 2;
+	int step2 = AFdata->i_step / 2;
+	if (step2 <= 0 ) step2 = 1;
+	int focus=0;
+	
+	switch (AFdata->flag) 
+	{
+		/*--------- first time - run sharpness algorithm -----------------*/
+		if(AFdata->ind >= 20) 
+		{
+			g_printerr ("WARNING ind=%d exceeds 20\n",AFdata->ind);
+			AFdata->ind = 10;
+		}
+		
+		case 0: /*sample left to right at higher step*/
+			AFdata->arr_sharp[AFdata->ind] = AFdata->sharpness;
+			AFdata->arr_foc[AFdata->ind] = AFdata->focus;
+			/*reached max focus value*/
+			if (AFdata->focus >= AFdata->right ) 
+			{	/*get left and right from arr_sharp*/
+				focus=Sort(AFdata,AFdata->ind);
+				/*get a window around the best value*/
+				AFdata->left = (focus- step/2);
+				AFdata->right = (focus + step/2);
+				if (AFdata->left < AFdata->f_min) AFdata->left = AFdata->f_min;
+				if (AFdata->right > AFdata->f_max) AFdata->right = AFdata->f_max;
+				AFdata->focus = AFdata->left;
+				AFdata->ind=0;
+				AFdata->flag = 1;
+			} 
+			else /*increment focus*/
+			{ 
+				AFdata->focus=AFdata->arr_foc[AFdata->ind] + step; /*next focus*/
+				AFdata->ind++;
+				AFdata->flag = 0;
+			}
+			break;
+		case 1: /*sample left to right at lower step - fine tune*/ 
+			AFdata->arr_sharp[AFdata->ind] = AFdata->sharpness;
+			AFdata->arr_foc[AFdata->ind] = AFdata->focus;
+			/*reached window max focus*/
+			if (AFdata->focus >= AFdata->right ) 
+			{	/*get left and right from arr_sharp*/
+				focus=Sort(AFdata,AFdata->ind);
+				/*get the best value*/
+				AFdata->focus = focus;
+				AFdata->focus_sharpness = AFdata->arr_sharp[AFdata->ind];
+				AFdata->step = AFdata->i_step; /*first step for focus tracking*/
+				AFdata->focusDir = FLAT; /*no direction for focus*/
+				AFdata->flag = 2;
+			}
+			else /*increment focus*/
+			{ 
+				AFdata->focus=AFdata->arr_foc[AFdata->ind] + step2; /*next focus*/
+				AFdata->ind++;
+				AFdata->flag = 1;
+			}
+			break;
+		case 2: /* set treshold in order to sharpness*/
+			if (AFdata->setFocus) 
+			{	
+				/*reset*/
+				AFdata->setFocus = 0;
+				AFdata->flag= 0;
+				AFdata->right = AFdata->f_max;
+				AFdata->left = AFdata->f_min + AFdata->i_step;
+				AFdata->ind = 0;
+			}
+			else 
+			{
+				/*track focus*/
+				AFdata->focus_sharpness = AFdata->sharpness;
+				AFdata->flag = 3;
+				AFdata->sharpLeft = 0;
+				AFdata->sharpRight = 0;
+				AFdata->focus += AFdata->step; /*check right*/
+			}
+			break;
+		case 3:
+			/*track focus*/
+			AFdata->flag = 4;
+			AFdata->sharpRight = AFdata->sharpness;
+			AFdata->focus -= (2*AFdata->step); /*check left*/
+			break;
+		case 4:
+			/*track focus*/
+			AFdata->sharpLeft=AFdata->sharpness;
+			int ret=0;
+			ret=checkFocus(AFdata);
+			switch (ret) 
+			{
+				case LOCAL_MAX:
+					AFdata->focus += AFdata->step; /*return to orig. focus*/
+					AFdata->step = AFdata->i_step;
+					AFdata->flag = 2;
+					break;
+					
+				case FLAT:
+					if(AFdata->focusDir == FLAT) 
+					{
+						AFdata->step = AFdata->i_step;
+						if(AFdata->focus_sharpness < 4 * _TH_) 
+						{
+							/* 99% chance we lost focus     */	
+							/* move focus to half the range */
+							AFdata->focus = AFdata->f_max / 2;
+						}
+						else
+						{
+							AFdata->focus += AFdata->step; /*return to orig. focus*/
+						}
+						AFdata->flag = 2;
+					}
+					else if (AFdata->focusDir == RIGHT) 
+					{
+						AFdata->focus += 2*AFdata->step; /*go right*/
+						AFdata->step = AFdata->i_step;
+						AFdata->flag = 2;
+					} 
+					else 
+					{	/*go left*/
+						AFdata->step = AFdata->i_step;
+						AFdata->flag = 2;
+					}
+					break;
+					
+				case RIGHT:
+					AFdata->focus += 2*AFdata->step; /*go right*/
+					AFdata->flag = 2;
+					break;
+					
+				case LEFT:
+					/*keep focus on left*/
+					AFdata->flag = 2;
+					break;
+					
+				case INCSTEP:
+					AFdata->focus += AFdata->step; /*return to orig. focus*/
+					AFdata->step = 2 * AFdata->i_step;
+					AFdata->flag = 2;
+					break;
+			}
+			break;
+	}
+	/*clip focus, right and left*/
+	AFdata->focus=(AFdata->focus > AFdata->f_max) ? AFdata->f_max : ((AFdata->focus < AFdata->f_min) ? AFdata->f_min : AFdata->focus);
+	AFdata->right=(AFdata->right > AFdata->f_max) ? AFdata->f_max : ((AFdata->right < AFdata->f_min) ? AFdata->f_min : AFdata->right);
+	AFdata->left =(AFdata->left > AFdata->f_max) ? AFdata->f_max : ((AFdata->left < AFdata->f_min) ? AFdata->f_min : AFdata->left);
+
+	return AFdata->focus;
+}
diff --git a/uvc_camera/src/camera.cpp b/uvc_camera/src/camera.cpp
index 442df09..beef60a 100644
--- a/uvc_camera/src/camera.cpp
+++ b/uvc_camera/src/camera.cpp
@@ -55,7 +55,7 @@ Camera::Camera(ros::NodeHandle _comm_nh, ros::NodeHandle _param_nh) :
 
       /* initialize the cameras */
       cam = new uvc_cam::Cam(device.c_str(), uvc_cam::Cam::MODE_RGB, width, height, fps);
-      cam->set_motion_thresholds(100, -1);
+      cam->set_motion_thresholds(100, -1); 
 
       /* and turn on the streamer */
       ok = true;
@@ -115,7 +115,7 @@ Camera::Camera(ros::NodeHandle _comm_nh, ros::NodeHandle _param_nh) :
              image->data.resize(image->step * image->height);
 
              memcpy(&image->data[0], img_frame, width*height * 3);
-
+	     //////////////////////////////////////////////////////////////////////////////////////////////////////
              pub.publish(image);
 
              sendInfo(image, capture_time);
diff --git a/uvc_camera/src/dct.cpp b/uvc_camera/src/dct.cpp
new file mode 100644
index 0000000..ce7174c
--- /dev/null
+++ b/uvc_camera/src/dct.cpp
@@ -0,0 +1,139 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+/*******************************************************************************#
+#                                                                               #
+#  dct for Jpeg encoder                                                         #
+#                                                                               # 
+#  Adapted for linux, Paulo Assis, 2007 <pj.assis@gmail.com>                    #
+********************************************************************************/
+
+#include "uvc_cam/dct.h"
+#include "uvc_cam/defs.h"
+
+
+/* Level shifting to get 8 bit SIGNED values for the data  */
+void levelshift (INT16* const data)
+{
+	INT16 i;
+
+	for (i=63; i>=0; i--)
+		data [i] -= 128;
+}
+
+/* DCT for One block(8x8) */
+void DCT (INT16 *data)
+{
+	UINT16 i;
+	INT32 x0, x1, x2, x3, x4, x5, x6, x7, x8;
+	INT16 *tmp_ptr;
+	tmp_ptr=data;
+	/*  All values are shifted left by 10   */
+	/*  and rounded off to nearest integer  */
+
+	/* scale[0] = 1
+	 * scale[k] = cos(k*PI/16)*root(2)
+	 */
+	static const UINT16 c1=1420;    /* cos PI/16 * root(2)  */
+	static const UINT16 c2=1338;    /* cos PI/8 * root(2)   */
+	static const UINT16 c3=1204;    /* cos 3PI/16 * root(2) */
+	static const UINT16 c5=805;     /* cos 5PI/16 * root(2) */
+	static const UINT16 c6=554;     /* cos 3PI/8 * root(2)  */
+	static const UINT16 c7=283;     /* cos 7PI/16 * root(2) */
+
+	static const UINT16 s1=3;
+	static const UINT16 s2=10;
+	static const UINT16 s3=13;
+
+
+	/* row pass */
+	for (i=8; i>0; i--)
+	{
+		x8 = data [0] + data [7];
+		x0 = data [0] - data [7];
+
+		x7 = data [1] + data [6];
+		x1 = data [1] - data [6];
+
+		x6 = data [2] + data [5];
+		x2 = data [2] - data [5];
+
+		x5 = data [3] + data [4];
+		x3 = data [3] - data [4];
+
+		x4 = x8 + x5;
+		x8 -= x5;
+
+		x5 = x7 + x6;
+		x7 -= x6;
+
+		data [0] = (INT16) (x4 + x5);
+		data [4] = (INT16) (x4 - x5);
+
+		data [2] = (INT16) ((x8*c2 + x7*c6) >> s2);
+		data [6] = (INT16) ((x8*c6 - x7*c2) >> s2);
+
+		data [7] = (INT16) ((x0*c7 - x1*c5 + x2*c3 - x3*c1) >> s2);
+		data [5] = (INT16) ((x0*c5 - x1*c1 + x2*c7 + x3*c3) >> s2);
+		data [3] = (INT16) ((x0*c3 - x1*c7 - x2*c1 - x3*c5) >> s2);
+		data [1] = (INT16) ((x0*c1 + x1*c3 + x2*c5 + x3*c7) >> s2);
+
+		data += 8;
+	}
+
+	data = tmp_ptr;/* return to start of mcu */
+	
+	/* column pass */
+	for (i=8; i>0; i--)
+	{
+		x8 = data [0] + data [56];
+		x0 = data [0] - data [56];
+
+		x7 = data [8] + data [48];
+		x1 = data [8] - data [48];
+
+		x6 = data [16] + data [40];
+		x2 = data [16] - data [40];
+
+		x5 = data [24] + data [32];
+		x3 = data [24] - data [32];
+
+		x4 = x8 + x5;
+		x8 -= x5;
+
+		x5 = x7 + x6;
+		x7 -= x6;
+
+		data [0] = (INT16) ((x4 + x5) >> s1);
+		data [32] = (INT16) ((x4 - x5) >> s1);
+
+		data [16] = (INT16) ((x8*c2 + x7*c6) >> s3);
+		data [48] = (INT16) ((x8*c6 - x7*c2) >> s3);
+
+		data [56] = (INT16) ((x0*c7 - x1*c5 + x2*c3 - x3*c1) >> s3);
+		data [40] = (INT16) ((x0*c5 - x1*c1 + x2*c7 + x3*c3) >> s3);
+		data [24] = (INT16) ((x0*c3 - x1*c7 - x2*c1 - x3*c5) >> s3);
+		data [8] = (INT16) ((x0*c1 + x1*c3 + x2*c5 + x3*c7) >> s3);
+
+		data++;
+	}
+	data=tmp_ptr; /* return to start of mcu */
+}
diff --git a/uvc_camera/src/ms_time.cpp b/uvc_camera/src/ms_time.cpp
new file mode 100644
index 0000000..ca0376e
--- /dev/null
+++ b/uvc_camera/src/ms_time.cpp
@@ -0,0 +1,92 @@
+/*******************************************************************************#
+#           guvcview              http://guvcview.berlios.de                    #
+#                                                                               #
+#           Paulo Assis <pj.assis@gmail.com>                                    #
+#                                                                               #
+# This program is free software; you can redistribute it and/or modify          #
+# it under the terms of the GNU General Public License as published by          #
+# the Free Software Foundation; either version 2 of the License, or             #
+# (at your option) any later version.                                           #
+#                                                                               #
+# This program is distributed in the hope that it will be useful,               #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
+# GNU General Public License for more details.                                  #
+#                                                                               #
+# You should have received a copy of the GNU General Public License             #
+# along with this program; if not, write to the Free Software                   #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
+#                                                                               #
+********************************************************************************/
+
+
+#include <time.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#include "uvc_cam/ms_time.h"
+
+/*------------------------------ get time ------------------------------------*/
+/*in miliseconds*/
+DWORD ms_time (void)
+{
+	GTimeVal *tod;
+	tod = g_new0(GTimeVal, 1);
+	g_get_current_time(tod);
+	DWORD mst = (DWORD) tod->tv_sec * 1000 + (DWORD) tod->tv_usec / 1000;
+	g_free(tod);
+	return (mst);
+}
+/*in microseconds*/
+ULLONG us_time(void)
+{
+	GTimeVal *tod;
+	tod = g_new0(GTimeVal, 1);
+	g_get_current_time(tod);
+	ULLONG ust = (DWORD) tod->tv_sec * G_USEC_PER_SEC + (DWORD) tod->tv_usec;
+	g_free(tod);
+	return (ust);
+}
+
+/*REAL TIME CLOCK*/
+/*in nanoseconds*/
+ULLONG ns_time (void)
+{
+	static struct timespec ts;
+	clock_gettime(CLOCK_REALTIME, &ts);
+	return ((ULLONG) ts.tv_sec * G_NSEC_PER_SEC + (ULLONG) ts.tv_nsec);
+}
+
+/*MONOTONIC CLOCK*/
+/*in nanosec*/
+UINT64 ns_time_monotonic()
+{
+	static struct timespec ts;
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+	return ((UINT64) ts.tv_sec * G_NSEC_PER_SEC + (ULLONG) ts.tv_nsec);
+}
+
+//sleep for given time in ms
+void sleep_ms(int ms_time)
+{
+	gulong sleep_us = ms_time *1000; /*convert to microseconds*/
+	g_usleep( sleep_us );/*sleep for sleep_ms ms*/
+}
+
+/*wait on cond by sleeping for n_loops of sleep_ms ms (test var==val every loop)*/
+/*return remaining number of loops (if 0 then a stall occurred)              */
+int wait_ms(gboolean* var, gboolean val, GMutex *mutex, int ms_time, int n_loops)
+{
+	int n=n_loops;
+	g_mutex_lock(mutex);
+		while( (*var!=val) && ( n > 0 ) ) /*wait at max (n_loops*sleep_ms) ms */
+		{
+			g_mutex_unlock(mutex);
+			n--;
+			sleep_ms( ms_time );/*sleep for sleep_ms ms*/
+			g_mutex_lock(mutex);
+		};
+	g_mutex_unlock(mutex);
+	return (n);
+}
+
diff --git a/uvc_camera/src/uvc_cam.cpp b/uvc_camera/src/uvc_cam.cpp
index 8b9e6b9..4a0165c 100644
--- a/uvc_camera/src/uvc_cam.cpp
+++ b/uvc_camera/src/uvc_cam.cpp
@@ -10,9 +10,15 @@
 #include <fcntl.h>
 #include <errno.h>
 #include "uvc_cam/uvc_cam.h"
+#include "uvc_cam/autofocus.h"
+#include <math.h>
+#include <stdlib.h>
 
 using std::string;
 using namespace uvc_cam;
+int last_focus;
+int control_value;
+struct focusData *AFdata;
 
 Cam::Cam(const char *_device, mode_t _mode, int _width, int _height, int _fps)
 : mode(_mode), device(_device),
@@ -160,7 +166,9 @@ Cam::Cam(const char *_device, mode_t _mode, int _width, int _height, int _fps)
     // the commented labels correspond to the controls in guvcview and uvcdynctrl
 
     //set_control(V4L2_CID_EXPOSURE_AUTO_NEW, 2);
+    printf("mytest: 1\n");
     set_control(10094851, 1); // Exposure, Auto Priority
+    printf("mytest: 2\n");
     set_control(10094849, 1); // Exposure, Auto
     //set_control(168062321, 0); //Disable video processing
     //set_control(0x9a9010, 100);
@@ -168,19 +176,33 @@ Cam::Cam(const char *_device, mode_t _mode, int _width, int _height, int _fps)
     //set_control(V4L2_CID_BRIGHTNESS, 140);
     //set_control(V4L2_CID_CONTRAST, 40);
     //set_control(V4L2_CID_WHITE_BALANCE_TEMP_AUTO_OLD, 0);
+    printf("mytest: 3\n");
     set_control(9963776, 128); //Brightness
+    printf("mytest: 4\n");
     set_control(9963777, 32); //Contrast
+    printf("mytest: 5\n");
     set_control(9963788, 1); // White Balance Temperature, Auto
-    set_control(9963802, 5984); // White Balance Temperature
+    printf("mytest: 6\n");
+    //set_control(9963802, 50); // White Balance Temperature
+    printf("mytest: 7\n");
     set_control(9963800, 2);  // power line frequency to 60 hz
-    set_control(9963795, 200); // Gain
+    printf("mytest: 8\n");
+    set_control(9963795, 0); // Gain
+    printf("mytest: 9\n");
     set_control(9963803, 224); // Sharpness
+    printf("mytest: 10\n");
     set_control(9963804, 1); //Backlight Compensation
-    set_control(10094850, 250); // Exposure (Absolute)
-    set_control(168062212, 16); //Focus (absolute)
+    printf("mytest: 11\n");
+    set_control(10094850, 166); // Exposure (Absolute)
+    printf("mytest: 12\n");
+    set_control(168062212, 0); //Focus (absolute)
+    printf("mytest: 13\n");
     set_control(168062213, 3); //LED1 Mode
+    printf("mytest: 14\n");
     set_control(168062214, 0); //LED1 Frequency
+    printf("mytest: 15\n");
     set_control(9963778, 32); // Saturation
+    printf("mytest: 16\n");
   }
   catch (std::runtime_error &ex)
   {
@@ -413,6 +435,15 @@ int Cam::grab(unsigned char **frame, uint32_t &bytes_used)
       *prgb++ = sat(pyuv[i+2]+1.402f*(pyuv[i+3]-128));
       */
     }
+
+    if(1)
+    {
+    	if(AFdata == NULL)
+    	  AFdata = initFocusData(255,0,1,168062212);
+    	auto_focus(AFdata,pyuv);
+    }
+
+
     memcpy(last_yuv_frame, pyuv, width * height * 2);
     if (num_pixels_different > motion_threshold_count) // default: always true
       *frame = rgb_frame;
@@ -431,6 +462,7 @@ int Cam::grab(unsigned char **frame, uint32_t &bytes_used)
     //if (bytes_used > 100)
       *frame = (unsigned char *)mem[buf.index];
   }
+
   return buf.index;
 }
 
@@ -468,3 +500,62 @@ void Cam::set_motion_thresholds(int lum, int count)
   motion_threshold_count = count;
 }
 
+void Cam::auto_focus(struct focusData *AFdata, unsigned char* frame)
+{
+
+
+	/*---------------- autofocus control ------------------*/
+
+    if (true)
+	{ /*AFdata = NULL if no focus control*/
+    	if (AFdata->focus < 0)
+    	{
+    		/*starting autofocus*/
+    		AFdata->focus = AFdata->left; /*start left*/
+    		control_value = AFdata->focus;
+    		/*if (set_ctrl (videoIn->fd, s->control_list, AFdata->id) != 0)
+    			printf("ERROR: couldn't set focus to %d\n", AFdata->focus);*/
+
+    		set_control(168062212, AFdata->focus);
+
+    		/*number of frames until focus is stable*/
+    		/*1.4 ms focus time - every 1 step*/
+    		AFdata->focus_wait = (int) abs(AFdata->focus-last_focus)*1.4/(1000/fps)+1;
+    		last_focus = AFdata->focus;
+    	}
+    	else
+    	{
+    		if (AFdata->focus_wait == 0)
+    		{
+    			AFdata->sharpness=getSharpness (frame, width, height, 5);
+    			/*if (global->debug)*/
+
+    			printf("sharp=%d focus_sharp=%d foc=%d right=%d left=%d ind=%d flag=%d\n",
+    			AFdata->sharpness,AFdata->focus_sharpness,
+    			AFdata->focus, AFdata->right, AFdata->left,
+    			AFdata->ind, AFdata->flag);
+
+    			AFdata->focus=getFocusVal (AFdata);
+    			if ((AFdata->focus != last_focus))
+    			{
+    				control_value = AFdata->focus;
+    				/*if (set_ctrl (videoIn->fd, s->control_list, AFdata->id) != 0)
+    					printf("ERROR: couldn't set focus to %d\n",
+    				AFdata->focus);*/
+    				set_control(168062212, AFdata->focus);
+    				/*number of frames until focus is stable*/
+    				/*1.4 ms focus time - every 1 step*/
+    				AFdata->focus_wait = (int) abs(AFdata->focus-last_focus)*1.4/(1000/fps)+1;
+    			}
+    			last_focus = AFdata->focus;
+    		}
+    		else
+    		{
+    			AFdata->focus_wait--;
+    			/*if (global->debug)
+    				printf("Wait Frame: %d\n",AFdata->focus_wait);*/
+    		}
+    	}
+	}
+}
+
