
to look at

-what exactly the algorithm outputs
	- also trajectory output
	- save node wise/send model, needs investigation
-what is the data in the bag file - set of poses?
	- the optimizer - all vertices (nodes) and edges (transforms) between them
-need the set of pointclouds and respective images and transforms for surface reconstruction (dejan)
	- All the nodes have their original pointclouds.  Each node has a respective transform from the optimizer

parameters to play with or investigate

    config["min_matches"]                   = static_cast<int> (25);           //if using SiftGPU and GLSL you should use max. 60 matches
	//usually many matches, over 100
	// increasing this number seems like a good idea, however it also reduces the number of edges in the graph.

    config["min_translation_meter"]         = static_cast<double> (0.05);
    config["min_rotation_degree"]           = static_cast<int> (2.5);
    // If a transform is too small (as specified by the parameters above) It will not be added to the graph
    // this means going too slow will not improve performance
    
    config["min_time_reported"]  	=1e9	// reports the runtime to rxlogger when time exceeds this value.  In this case never
    config["squared_meshing_threshold"] 	//something to do with the visualizer
    config["connectivity"]                  = static_cast<int> (10);
    // Number of nodes for the current node to match against to find edges
    // used as parameter max_targets in getPotentialEdgeTargets  
    /// max_targets determines how many potential edges are wanted
	/// max_targets < 0: No limit
	/// max_targets = 0: Compare to first frame only
	/// max_targets = 1: Compare to previous frame only
	/// max_targets > 1: Select intelligently (TODO: rather stupid at the moment)
    
    config["max_connections"] // max number of edges a node may have

    config["concurrent_node_construction"]  = static_cast<bool> (true);		// allows multiple nodes to be processed (ransac matching etc) simultaneously
    config["concurrent_edge_construction"]  = static_cast<bool> (true);
    	// Allows simultaneous processing of node matching to add edges.  Comment from code:
            //First compile a qlist of the nodes to be compared, then run the comparisons in parallel,
            //collecting a qlist of the results (using the blocking version of mapped).
            
    config["voxelfilter_size"]  // Filters the point cloud as a node is created.  <=0 turns it off 

    config["wide_queue_size"]    	// Not used
    config["optimizer_skip_step"] 	// How often should the graph be optimized. E.g. 5 means optimize once for every 5 nodes that are added to the graph
    config["data_skip_step"]   		
    	// skips 1 out of x camera frames (at callback level). set to 1 to turn off.  This only applies for stereo and no cloud data callbacks

    config["depth_scaling_factor"] 		// scales the Z values of the point cloud.  Used when mapping features to point clouds

    config["keep_all_nodes"]  
      // if a node is added to the graph, but no edges are found, setting this value to true
      // will add an edge same as the edge of the last match (constant motion assumption)
